//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export class Client {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    /**
     * @return Success
     */
    byEmployeeId(employeeId: number , cancelToken?: CancelToken | undefined): Promise<AttestationIListResponseVm> {
        let url_ = this.baseUrl + "/api/Attestation/ByEmployeeId/{employeeId}";
        if (employeeId === undefined || employeeId === null)
            throw new Error("The parameter 'employeeId' must be defined.");
        url_ = url_.replace("{employeeId}", encodeURIComponent("" + employeeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByEmployeeId(_response);
        });
    }

    protected processByEmployeeId(response: AxiosResponse): Promise<AttestationIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttestationIListResponseVm.fromJS(resultData200);
            return Promise.resolve<AttestationIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttestationIListResponseVm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    attestationPOST(body: Attestation | undefined , cancelToken?: CancelToken | undefined): Promise<AttestationResponseVm> {
        let url_ = this.baseUrl + "/api/Attestation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAttestationPOST(_response);
        });
    }

    protected processAttestationPOST(response: AxiosResponse): Promise<AttestationResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttestationResponseVm.fromJS(resultData200);
            return Promise.resolve<AttestationResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttestationResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    attestationGET(  cancelToken?: CancelToken | undefined): Promise<AttestationIListResponseVm> {
        let url_ = this.baseUrl + "/api/Attestation";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAttestationGET(_response);
        });
    }

    protected processAttestationGET(response: AxiosResponse): Promise<AttestationIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttestationIListResponseVm.fromJS(resultData200);
            return Promise.resolve<AttestationIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttestationIListResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    attestationDELETE(id: number , cancelToken?: CancelToken | undefined): Promise<BaseResponseVm> {
        let url_ = this.baseUrl + "/api/Attestation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAttestationDELETE(_response);
        });
    }

    protected processAttestationDELETE(response: AxiosResponse): Promise<BaseResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BaseResponseVm.fromJS(resultData200);
            return Promise.resolve<BaseResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    attestationGET2(id: number , cancelToken?: CancelToken | undefined): Promise<AttestationResponseVm> {
        let url_ = this.baseUrl + "/api/Attestation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processAttestationGET2(_response);
        });
    }

    protected processAttestationGET2(response: AxiosResponse): Promise<AttestationResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AttestationResponseVm.fromJS(resultData200);
            return Promise.resolve<AttestationResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AttestationResponseVm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    login(body: LoginModel | undefined , cancelToken?: CancelToken | undefined): Promise<JwtVmResponseVm> {
        let url_ = this.baseUrl + "/api/Auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: AxiosResponse): Promise<JwtVmResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = JwtVmResponseVm.fromJS(resultData200);
            return Promise.resolve<JwtVmResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<JwtVmResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    byLegalEntityId(legalEntityId: number , cancelToken?: CancelToken | undefined): Promise<CertificationIListResponseVm> {
        let url_ = this.baseUrl + "/api/Certification/ByLegalEntityId/{legalEntityId}";
        if (legalEntityId === undefined || legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' must be defined.");
        url_ = url_.replace("{legalEntityId}", encodeURIComponent("" + legalEntityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByLegalEntityId(_response);
        });
    }

    protected processByLegalEntityId(response: AxiosResponse): Promise<CertificationIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CertificationIListResponseVm.fromJS(resultData200);
            return Promise.resolve<CertificationIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CertificationIListResponseVm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    certificationPOST(body: Certification | undefined , cancelToken?: CancelToken | undefined): Promise<CertificationResponseVm> {
        let url_ = this.baseUrl + "/api/Certification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificationPOST(_response);
        });
    }

    protected processCertificationPOST(response: AxiosResponse): Promise<CertificationResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CertificationResponseVm.fromJS(resultData200);
            return Promise.resolve<CertificationResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CertificationResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    certificationGET(  cancelToken?: CancelToken | undefined): Promise<CertificationIListResponseVm> {
        let url_ = this.baseUrl + "/api/Certification";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificationGET(_response);
        });
    }

    protected processCertificationGET(response: AxiosResponse): Promise<CertificationIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CertificationIListResponseVm.fromJS(resultData200);
            return Promise.resolve<CertificationIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CertificationIListResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    certificationDELETE(id: number , cancelToken?: CancelToken | undefined): Promise<BaseResponseVm> {
        let url_ = this.baseUrl + "/api/Certification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificationDELETE(_response);
        });
    }

    protected processCertificationDELETE(response: AxiosResponse): Promise<BaseResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BaseResponseVm.fromJS(resultData200);
            return Promise.resolve<BaseResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    certificationGET2(id: number , cancelToken?: CancelToken | undefined): Promise<CertificationResponseVm> {
        let url_ = this.baseUrl + "/api/Certification/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processCertificationGET2(_response);
        });
    }

    protected processCertificationGET2(response: AxiosResponse): Promise<CertificationResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CertificationResponseVm.fromJS(resultData200);
            return Promise.resolve<CertificationResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CertificationResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    debug(  cancelToken?: CancelToken | undefined): Promise<void> {
        let url_ = this.baseUrl + "/api/Debug";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processDebug(_response);
        });
    }

    protected processDebug(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(null as any);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    employeePOST(body: PersonBaseVm | undefined , cancelToken?: CancelToken | undefined): Promise<PersonVmResponseVm> {
        let url_ = this.baseUrl + "/api/Employee";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmployeePOST(_response);
        });
    }

    protected processEmployeePOST(response: AxiosResponse): Promise<PersonVmResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PersonVmResponseVm.fromJS(resultData200);
            return Promise.resolve<PersonVmResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonVmResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    employeeGET(  cancelToken?: CancelToken | undefined): Promise<PersonVmIListResponseVm> {
        let url_ = this.baseUrl + "/api/Employee";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmployeeGET(_response);
        });
    }

    protected processEmployeeGET(response: AxiosResponse): Promise<PersonVmIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PersonVmIListResponseVm.fromJS(resultData200);
            return Promise.resolve<PersonVmIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonVmIListResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    employeeDELETE(id: number , cancelToken?: CancelToken | undefined): Promise<BaseResponseVm> {
        let url_ = this.baseUrl + "/api/Employee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmployeeDELETE(_response);
        });
    }

    protected processEmployeeDELETE(response: AxiosResponse): Promise<BaseResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BaseResponseVm.fromJS(resultData200);
            return Promise.resolve<BaseResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    employeeGET2(id: number , cancelToken?: CancelToken | undefined): Promise<PersonVmResponseVm> {
        let url_ = this.baseUrl + "/api/Employee/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processEmployeeGET2(_response);
        });
    }

    protected processEmployeeGET2(response: AxiosResponse): Promise<PersonVmResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PersonVmResponseVm.fromJS(resultData200);
            return Promise.resolve<PersonVmResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PersonVmResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    byLegalEntityId2(legalEntityId: number , cancelToken?: CancelToken | undefined): Promise<InsuranceIListResponseVm> {
        let url_ = this.baseUrl + "/api/Insurance/ByLegalEntityId/{legalEntityId}";
        if (legalEntityId === undefined || legalEntityId === null)
            throw new Error("The parameter 'legalEntityId' must be defined.");
        url_ = url_.replace("{legalEntityId}", encodeURIComponent("" + legalEntityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processByLegalEntityId2(_response);
        });
    }

    protected processByLegalEntityId2(response: AxiosResponse): Promise<InsuranceIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsuranceIListResponseVm.fromJS(resultData200);
            return Promise.resolve<InsuranceIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsuranceIListResponseVm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insurancePOST(body: Insurance | undefined , cancelToken?: CancelToken | undefined): Promise<InsuranceResponseVm> {
        let url_ = this.baseUrl + "/api/Insurance";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsurancePOST(_response);
        });
    }

    protected processInsurancePOST(response: AxiosResponse): Promise<InsuranceResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsuranceResponseVm.fromJS(resultData200);
            return Promise.resolve<InsuranceResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsuranceResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    insuranceGET(  cancelToken?: CancelToken | undefined): Promise<InsuranceIListResponseVm> {
        let url_ = this.baseUrl + "/api/Insurance";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsuranceGET(_response);
        });
    }

    protected processInsuranceGET(response: AxiosResponse): Promise<InsuranceIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsuranceIListResponseVm.fromJS(resultData200);
            return Promise.resolve<InsuranceIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsuranceIListResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    insuranceDELETE(id: number , cancelToken?: CancelToken | undefined): Promise<BaseResponseVm> {
        let url_ = this.baseUrl + "/api/Insurance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsuranceDELETE(_response);
        });
    }

    protected processInsuranceDELETE(response: AxiosResponse): Promise<BaseResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BaseResponseVm.fromJS(resultData200);
            return Promise.resolve<BaseResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    insuranceGET2(id: number , cancelToken?: CancelToken | undefined): Promise<InsuranceResponseVm> {
        let url_ = this.baseUrl + "/api/Insurance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processInsuranceGET2(_response);
        });
    }

    protected processInsuranceGET2(response: AxiosResponse): Promise<InsuranceResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InsuranceResponseVm.fromJS(resultData200);
            return Promise.resolve<InsuranceResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InsuranceResponseVm>(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    legalEntityPOST(body: LegalEntityBaseVm | undefined , cancelToken?: CancelToken | undefined): Promise<LegalEntityVmResponseVm> {
        let url_ = this.baseUrl + "/api/LegalEntity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: AxiosRequestConfig = {
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLegalEntityPOST(_response);
        });
    }

    protected processLegalEntityPOST(response: AxiosResponse): Promise<LegalEntityVmResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LegalEntityVmResponseVm.fromJS(resultData200);
            return Promise.resolve<LegalEntityVmResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LegalEntityVmResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    legalEntityGET(  cancelToken?: CancelToken | undefined): Promise<LegalEntityVmIListResponseVm> {
        let url_ = this.baseUrl + "/api/LegalEntity";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLegalEntityGET(_response);
        });
    }

    protected processLegalEntityGET(response: AxiosResponse): Promise<LegalEntityVmIListResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LegalEntityVmIListResponseVm.fromJS(resultData200);
            return Promise.resolve<LegalEntityVmIListResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LegalEntityVmIListResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    legalEntityDELETE(id: number , cancelToken?: CancelToken | undefined): Promise<BaseResponseVm> {
        let url_ = this.baseUrl + "/api/LegalEntity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLegalEntityDELETE(_response);
        });
    }

    protected processLegalEntityDELETE(response: AxiosResponse): Promise<BaseResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = BaseResponseVm.fromJS(resultData200);
            return Promise.resolve<BaseResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<BaseResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    legalEntityGET2(id: number , cancelToken?: CancelToken | undefined): Promise<LegalEntityVmResponseVm> {
        let url_ = this.baseUrl + "/api/LegalEntity/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processLegalEntityGET2(_response);
        });
    }

    protected processLegalEntityGET2(response: AxiosResponse): Promise<LegalEntityVmResponseVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LegalEntityVmResponseVm.fromJS(resultData200);
            return Promise.resolve<LegalEntityVmResponseVm>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LegalEntityVmResponseVm>(null as any);
    }

    /**
     * @return Success
     */
    getWeatherForecast(  cancelToken?: CancelToken | undefined): Promise<WeatherForecast[]> {
        let url_ = this.baseUrl + "/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: AxiosRequestConfig = {
            method: "GET",
            url: url_,
            headers: {
                "Accept": "text/plain"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processGetWeatherForecast(_response);
        });
    }

    protected processGetWeatherForecast(response: AxiosResponse): Promise<WeatherForecast[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<WeatherForecast[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<WeatherForecast[]>(null as any);
    }
}

export class Attestation implements IAttestation {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    attestationType?: AttestationType;
    number?: string | undefined;
    employeeId?: number;
    employees?: Employee;

    constructor(data?: IAttestation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDeleted = _data["isDeleted"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.attestationType = _data["attestationType"];
            this.number = _data["number"];
            this.employeeId = _data["employeeId"];
            this.employees = _data["employees"] ? Employee.fromJS(_data["employees"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Attestation {
        data = typeof data === 'object' ? data : {};
        let result = new Attestation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["attestationType"] = this.attestationType;
        data["number"] = this.number;
        data["employeeId"] = this.employeeId;
        data["employees"] = this.employees ? this.employees.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAttestation {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    attestationType?: AttestationType;
    number?: string | undefined;
    employeeId?: number;
    employees?: Employee;
}

export class AttestationIListResponseVm implements IAttestationIListResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Attestation[] | undefined;

    constructor(data?: IAttestationIListResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Attestation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AttestationIListResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new AttestationIListResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAttestationIListResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Attestation[] | undefined;
}

export class AttestationResponseVm implements IAttestationResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Attestation;

    constructor(data?: IAttestationResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? Attestation.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AttestationResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new AttestationResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAttestationResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Attestation;
}

/** 0 = Agent, 1 = Broker, 2 = Specialist */
export enum AttestationType {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class BaseResponseVm implements IBaseResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;

    constructor(data?: IBaseResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
        }
    }

    static fromJS(data: any): BaseResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new BaseResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        return data;
    }
}

export interface IBaseResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
}

export class Certification implements ICertification {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    number?: string | undefined;
    legalEntityId?: number;
    legalEntity?: LegalEntity;

    constructor(data?: ICertification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDeleted = _data["isDeleted"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.number = _data["number"];
            this.legalEntityId = _data["legalEntityId"];
            this.legalEntity = _data["legalEntity"] ? LegalEntity.fromJS(_data["legalEntity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Certification {
        data = typeof data === 'object' ? data : {};
        let result = new Certification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["number"] = this.number;
        data["legalEntityId"] = this.legalEntityId;
        data["legalEntity"] = this.legalEntity ? this.legalEntity.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICertification {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    number?: string | undefined;
    legalEntityId?: number;
    legalEntity?: LegalEntity;
}

export class CertificationIListResponseVm implements ICertificationIListResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Certification[] | undefined;

    constructor(data?: ICertificationIListResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Certification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CertificationIListResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationIListResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICertificationIListResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Certification[] | undefined;
}

export class CertificationResponseVm implements ICertificationResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Certification;

    constructor(data?: ICertificationResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? Certification.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CertificationResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new CertificationResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICertificationResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Certification;
}

export class Employee implements IEmployee {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    inn?: string | undefined;
    legalEntityId?: number;
    legalEntity?: LegalEntity;
    attestations?: Attestation[] | undefined;

    constructor(data?: IEmployee) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDeleted = _data["isDeleted"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.patronymic = _data["patronymic"];
            this.inn = _data["inn"];
            this.legalEntityId = _data["legalEntityId"];
            this.legalEntity = _data["legalEntity"] ? LegalEntity.fromJS(_data["legalEntity"]) : <any>undefined;
            if (Array.isArray(_data["attestations"])) {
                this.attestations = [] as any;
                for (let item of _data["attestations"])
                    this.attestations!.push(Attestation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Employee {
        data = typeof data === 'object' ? data : {};
        let result = new Employee();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["patronymic"] = this.patronymic;
        data["inn"] = this.inn;
        data["legalEntityId"] = this.legalEntityId;
        data["legalEntity"] = this.legalEntity ? this.legalEntity.toJSON() : <any>undefined;
        if (Array.isArray(this.attestations)) {
            data["attestations"] = [];
            for (let item of this.attestations)
                data["attestations"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEmployee {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    inn?: string | undefined;
    legalEntityId?: number;
    legalEntity?: LegalEntity;
    attestations?: Attestation[] | undefined;
}

export class Insurance implements IInsurance {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    legalEntityId?: number;
    legalEntity?: LegalEntity;

    constructor(data?: IInsurance) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDeleted = _data["isDeleted"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.legalEntityId = _data["legalEntityId"];
            this.legalEntity = _data["legalEntity"] ? LegalEntity.fromJS(_data["legalEntity"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Insurance {
        data = typeof data === 'object' ? data : {};
        let result = new Insurance();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["legalEntityId"] = this.legalEntityId;
        data["legalEntity"] = this.legalEntity ? this.legalEntity.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsurance {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    startDate?: Date;
    endDate?: Date;
    legalEntityId?: number;
    legalEntity?: LegalEntity;
}

export class InsuranceIListResponseVm implements IInsuranceIListResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Insurance[] | undefined;

    constructor(data?: IInsuranceIListResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Insurance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsuranceIListResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new InsuranceIListResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInsuranceIListResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Insurance[] | undefined;
}

export class InsuranceResponseVm implements IInsuranceResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Insurance;

    constructor(data?: IInsuranceResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? Insurance.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InsuranceResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new InsuranceResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInsuranceResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: Insurance;
}

export class JwtVm implements IJwtVm {
    token?: string | undefined;
    isAdmin?: boolean | undefined;

    constructor(data?: IJwtVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.isAdmin = _data["isAdmin"];
        }
    }

    static fromJS(data: any): JwtVm {
        data = typeof data === 'object' ? data : {};
        let result = new JwtVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["isAdmin"] = this.isAdmin;
        return data;
    }
}

export interface IJwtVm {
    token?: string | undefined;
}

export class JwtVmResponseVm implements IJwtVmResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: JwtVm;

    constructor(data?: IJwtVmResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? JwtVm.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): JwtVmResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new JwtVmResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IJwtVmResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: JwtVm;
}

export class LegalEntity implements ILegalEntity {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    employees?: Employee[] | undefined;
    certifications?: Certification[] | undefined;
    insurances?: Insurance[] | undefined;

    constructor(data?: ILegalEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.isDeleted = _data["isDeleted"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.name = _data["name"];
            this.membershipType = _data["membershipType"];
            this.legalEntityType = _data["legalEntityType"];
            this.votes = _data["votes"];
            this.inn = _data["inn"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            if (Array.isArray(_data["employees"])) {
                this.employees = [] as any;
                for (let item of _data["employees"])
                    this.employees!.push(Employee.fromJS(item));
            }
            if (Array.isArray(_data["certifications"])) {
                this.certifications = [] as any;
                for (let item of _data["certifications"])
                    this.certifications!.push(Certification.fromJS(item));
            }
            if (Array.isArray(_data["insurances"])) {
                this.insurances = [] as any;
                for (let item of _data["insurances"])
                    this.insurances!.push(Insurance.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LegalEntity {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["isDeleted"] = this.isDeleted;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["name"] = this.name;
        data["membershipType"] = this.membershipType;
        data["legalEntityType"] = this.legalEntityType;
        data["votes"] = this.votes;
        data["inn"] = this.inn;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        if (Array.isArray(this.employees)) {
            data["employees"] = [];
            for (let item of this.employees)
                data["employees"].push(item.toJSON());
        }
        if (Array.isArray(this.certifications)) {
            data["certifications"] = [];
            for (let item of this.certifications)
                data["certifications"].push(item.toJSON());
        }
        if (Array.isArray(this.insurances)) {
            data["insurances"] = [];
            for (let item of this.insurances)
                data["insurances"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILegalEntity {
    id?: number;
    isDeleted?: boolean;
    createdOn?: Date;
    modifiedOn?: Date;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    employees?: Employee[] | undefined;
    certifications?: Certification[] | undefined;
    insurances?: Insurance[] | undefined;
}

export class LegalEntityBaseVm implements ILegalEntityBaseVm {
    id?: number | undefined;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    certStartDate?: Date | undefined;
    certEndDate?: Date | undefined;
    certNumber?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    insStartDate?: Date | undefined;
    insEndDate?: Date | undefined;

    constructor(data?: ILegalEntityBaseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.membershipType = _data["membershipType"];
            this.legalEntityType = _data["legalEntityType"];
            this.votes = _data["votes"];
            this.inn = _data["inn"];
            this.certStartDate = _data["certStartDate"] ? new Date(_data["certStartDate"].toString()) : <any>undefined;
            this.certEndDate = _data["certEndDate"] ? new Date(_data["certEndDate"].toString()) : <any>undefined;
            this.certNumber = _data["certNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.insStartDate = _data["insStartDate"] ? new Date(_data["insStartDate"].toString()) : <any>undefined;
            this.insEndDate = _data["insEndDate"] ? new Date(_data["insEndDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LegalEntityBaseVm {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntityBaseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["membershipType"] = this.membershipType;
        data["legalEntityType"] = this.legalEntityType;
        data["votes"] = this.votes;
        data["inn"] = this.inn;
        data["certStartDate"] = this.certStartDate ? this.certStartDate.toISOString() : <any>undefined;
        data["certEndDate"] = this.certEndDate ? this.certEndDate.toISOString() : <any>undefined;
        data["certNumber"] = this.certNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["insStartDate"] = this.insStartDate ? this.insStartDate.toISOString() : <any>undefined;
        data["insEndDate"] = this.insEndDate ? this.insEndDate.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILegalEntityBaseVm {
    id?: number | undefined;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    certStartDate?: Date | undefined;
    certEndDate?: Date | undefined;
    certNumber?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    insStartDate?: Date | undefined;
    insEndDate?: Date | undefined;
}

/** 0 = IndividualEnterpreneur, 1 = Company */
export enum LegalEntityType {
    _0 = 0,
    _1 = 1,
}

export class LegalEntityVm implements ILegalEntityVm {
    id?: number | undefined;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    certStartDate?: Date | undefined;
    certEndDate?: Date | undefined;
    certNumber?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    insStartDate?: Date | undefined;
    insEndDate?: Date | undefined;
    createdOn?: Date | undefined;
    modifiedOn?: Date | undefined;

    constructor(data?: ILegalEntityVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.membershipType = _data["membershipType"];
            this.legalEntityType = _data["legalEntityType"];
            this.votes = _data["votes"];
            this.inn = _data["inn"];
            this.certStartDate = _data["certStartDate"] ? new Date(_data["certStartDate"].toString()) : <any>undefined;
            this.certEndDate = _data["certEndDate"] ? new Date(_data["certEndDate"].toString()) : <any>undefined;
            this.certNumber = _data["certNumber"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.insStartDate = _data["insStartDate"] ? new Date(_data["insStartDate"].toString()) : <any>undefined;
            this.insEndDate = _data["insEndDate"] ? new Date(_data["insEndDate"].toString()) : <any>undefined;
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): LegalEntityVm {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntityVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["membershipType"] = this.membershipType;
        data["legalEntityType"] = this.legalEntityType;
        data["votes"] = this.votes;
        data["inn"] = this.inn;
        data["certStartDate"] = this.certStartDate ? this.certStartDate.toISOString() : <any>undefined;
        data["certEndDate"] = this.certEndDate ? this.certEndDate.toISOString() : <any>undefined;
        data["certNumber"] = this.certNumber;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["insStartDate"] = this.insStartDate ? this.insStartDate.toISOString() : <any>undefined;
        data["insEndDate"] = this.insEndDate ? this.insEndDate.toISOString() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface ILegalEntityVm {
    id?: number | undefined;
    name?: string | undefined;
    membershipType?: MembershipType;
    legalEntityType?: LegalEntityType;
    votes?: number;
    inn?: string | undefined;
    certStartDate?: Date | undefined;
    certEndDate?: Date | undefined;
    certNumber?: string | undefined;
    phoneNumber?: string | undefined;
    email?: string | undefined;
    insStartDate?: Date | undefined;
    insEndDate?: Date | undefined;
    createdOn?: Date | undefined;
    modifiedOn?: Date | undefined;
}

export class LegalEntityVmIListResponseVm implements ILegalEntityVmIListResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: LegalEntityVm[] | undefined;

    constructor(data?: ILegalEntityVmIListResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(LegalEntityVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LegalEntityVmIListResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntityVmIListResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILegalEntityVmIListResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: LegalEntityVm[] | undefined;
}

export class LegalEntityVmResponseVm implements ILegalEntityVmResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: LegalEntityVm;

    constructor(data?: ILegalEntityVmResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? LegalEntityVm.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LegalEntityVmResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new LegalEntityVmResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface ILegalEntityVmResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: LegalEntityVm;
}

export class LoginModel implements ILoginModel {
    login?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    login?: string | undefined;
    password?: string | undefined;
}

/** 0 = Real, 1 = NotReal */
export enum MembershipType {
    _0 = 0,
    _1 = 1,
}

export class PersonBaseVm implements IPersonBaseVm {
    id?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    legalEntityId?: number;
    attNumber?: string | undefined;
    attStartDate?: Date | undefined;
    attEndDate?: Date | undefined;
    inn?: string | undefined;

    constructor(data?: IPersonBaseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.patronymic = _data["patronymic"];
            this.legalEntityId = _data["legalEntityId"];
            this.attNumber = _data["attNumber"];
            this.attStartDate = _data["attStartDate"] ? new Date(_data["attStartDate"].toString()) : <any>undefined;
            this.attEndDate = _data["attEndDate"] ? new Date(_data["attEndDate"].toString()) : <any>undefined;
            this.inn = _data["inn"];
        }
    }

    static fromJS(data: any): PersonBaseVm {
        data = typeof data === 'object' ? data : {};
        let result = new PersonBaseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["patronymic"] = this.patronymic;
        data["legalEntityId"] = this.legalEntityId;
        data["attNumber"] = this.attNumber;
        data["attStartDate"] = this.attStartDate ? this.attStartDate.toISOString() : <any>undefined;
        data["attEndDate"] = this.attEndDate ? this.attEndDate.toISOString() : <any>undefined;
        data["inn"] = this.inn;
        return data;
    }
}

export interface IPersonBaseVm {
    id?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    legalEntityId?: number;
    attNumber?: string | undefined;
    attStartDate?: Date | undefined;
    attEndDate?: Date | undefined;
    inn?: string | undefined;
}

export class PersonVm implements IPersonVm {
    id?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    legalEntityId?: number;
    attNumber?: string | undefined;
    attStartDate?: Date | undefined;
    attEndDate?: Date | undefined;
    inn?: string | undefined;
    createdOn?: Date | undefined;
    modifiedOn?: Date | undefined;
    legalEntityName?: string | undefined;

    constructor(data?: IPersonVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.patronymic = _data["patronymic"];
            this.legalEntityId = _data["legalEntityId"];
            this.attNumber = _data["attNumber"];
            this.attStartDate = _data["attStartDate"] ? new Date(_data["attStartDate"].toString()) : <any>undefined;
            this.attEndDate = _data["attEndDate"] ? new Date(_data["attEndDate"].toString()) : <any>undefined;
            this.inn = _data["inn"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.modifiedOn = _data["modifiedOn"] ? new Date(_data["modifiedOn"].toString()) : <any>undefined;
            this.legalEntityName = _data["legalEntityName"];
        }
    }

    static fromJS(data: any): PersonVm {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["patronymic"] = this.patronymic;
        data["legalEntityId"] = this.legalEntityId;
        data["attNumber"] = this.attNumber;
        data["attStartDate"] = this.attStartDate ? this.attStartDate.toISOString() : <any>undefined;
        data["attEndDate"] = this.attEndDate ? this.attEndDate.toISOString() : <any>undefined;
        data["inn"] = this.inn;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["modifiedOn"] = this.modifiedOn ? this.modifiedOn.toISOString() : <any>undefined;
        data["legalEntityName"] = this.legalEntityName;
        return data;
    }
}

export interface IPersonVm {
    id?: number | undefined;
    name?: string | undefined;
    surname?: string | undefined;
    patronymic?: string | undefined;
    legalEntityId?: number;
    attNumber?: string | undefined;
    attStartDate?: Date | undefined;
    attEndDate?: Date | undefined;
    inn?: string | undefined;
    createdOn?: Date | undefined;
    modifiedOn?: Date | undefined;
    legalEntityName?: string | undefined;
}

export class PersonVmIListResponseVm implements IPersonVmIListResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: PersonVm[] | undefined;

    constructor(data?: IPersonVmIListResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(PersonVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonVmIListResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVmIListResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPersonVmIListResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: PersonVm[] | undefined;
}

export class PersonVmResponseVm implements IPersonVmResponseVm {
    success?: boolean;
    readonly generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: PersonVm;

    constructor(data?: IPersonVmResponseVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            (<any>this).generatedAt = _data["generatedAt"] ? new Date(_data["generatedAt"].toString()) : <any>undefined;
            this.userMessage = _data["userMessage"];
            this.systemMessage = _data["systemMessage"];
            this.data = _data["data"] ? PersonVm.fromJS(_data["data"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonVmResponseVm {
        data = typeof data === 'object' ? data : {};
        let result = new PersonVmResponseVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["generatedAt"] = this.generatedAt ? this.generatedAt.toISOString() : <any>undefined;
        data["userMessage"] = this.userMessage;
        data["systemMessage"] = this.systemMessage;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPersonVmResponseVm {
    success?: boolean;
    generatedAt?: Date;
    userMessage?: string | undefined;
    systemMessage?: string | undefined;
    data?: PersonVm;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}